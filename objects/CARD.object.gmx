<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>TARGETABLE</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// CLASS VARS
event_inherited();
cardSurface     = -1;
//owner         = see create_card()
name            = "";
class           = "";
description     = "This is the default card and if you're reading this, something went wrong";
abilities       = ds_list_create();
classes         = ds_list_create();
enchantments    = ds_list_create();
sprite_index    = spr_card;
image_index     = 0;
image_speed     = 0;
artVariant      = 0;
creatureResourceCost = 0;
spellResourceCost    = 0;
enchantResourceCost  = 0;
scale           = global.card_hand_scale;
fullyDrawn      = false;        // a check for animation
carddraw_xSpeed = 10;//room_width / room_speed;
slideSpeedMax   = 10;
snapDistance    = 4;
targetX         = room_width * 0.5;
targetY         = y;
casting         = false;
castingChecking = false;
activated       = false;
displayed       = false;        // display or don't display the card
position        = "none";       // in "hand", in "deck", on "board", in "graveyard", or "none"
faceUp          = false;        // 0 or 1, false or true, it corresponds to the image_index.
canUse          = false;
clicked         = false;
canPlay         = true;
canPlayFromGraveyard = true;
creatureResourceCost = 0;
spellResourceCost = 0;
enchantResourceCost = 0;
base_enchantmentSeparation = 12;
enchantmentSeparation = base_enchantmentSeparation;
isMouseOver = false;
global.selectingSummonSlot = false;
waitTime = 0;
hasActivationAbility = false;


setup_glowing();
setup_cardElementPositions();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// clean up datastructures

event_inherited();

if (ds_exists(abilities, ds_type_list)) {
    ds_list_destroy(abilities);
}

if (ds_exists(classes, ds_type_list)) {
    ds_list_destroy(classes);
}

if (ds_exists(enchantments, ds_type_list)) {
    ds_list_destroy(enchantments);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// state
//note: "clicked" occurs via CONTROLS object, not here.
event_inherited();


if (displayed == false) {
    visible = false;
} else visible = true;

image_index = faceUp;

// get mouseOver state
isMouseOver = false;
if (mouseOver()) {
    if (displayed) {
        isMouseOver = true;
    }
}

if (glowing) {
    calculate_glowAlpha();
}



// check if can't be played so we can darken the card
canUse = canPlayCard();


switch (position) {
    case "deck":
        displayed = false;
    break;
    
    case "drawing":
        displayed = true;
        fullyDrawn = false;
        faceUp = false;
        visible = true;
        scale = global.card_hand_scale;
        depth = global.drawing_depth;
        y = owner.hand.handY;
        targetY = owner.hand.handY;
        
        // finish
        if (x == targetX) {
            position    = "hand";
            fullyDrawn  = true;
        }
    break;
    
    case "hand":
        if (global.TURN == global.player) then faceUp = true;

        if (global.GAME_PHASE == "main") or (global.GAME_PHASE == "aftermath")
            then canUse = true;
        scale = global.card_hand_scale;
        if (owner.hand.forceHideContents)
        {
            displayed = false;
        }
        
        if (owner == global.enemy) {
            owner.hand.showContents = false;
        }
        
        if (global.currentCard != id) {
            targetY = owner.hand.handY;
        } else targetY = owner.hand.handY;
    break;
        
    case "board":
        canUse = true;
        displayed = true;
        faceUp = true;
        scale = global.card_board_scale;
    break;
        
    case "graveyard":
        if (canPlayFromGraveyard)
            then canUse = true;
            else canUse = false;
        y = owner.hand.handY;
        scale = global.card_grave_scale;
        if (owner.graveyard.forceHideContents) {
            displayed = false;
        }
    break;
}


// position card to left of screen when casting spell
if (global.choosingEffectTarget) or (global.summoning) {
    if (global.currentCard == id) {
        displayed = true;
        depth = global.cardZoomed_depth;
        targetX = 0;
        targetY = (room_height/2)
    }
}




// selecting a card to play
if ((position == "hand") or (position == "graveyard")) {
    if (!global.choosingEffectTarget) and (!global.choosingAttackTarget) {
        if (displayed) {
            // interactivity
            if (global.TURN == global.player) {
                if (owner == global.player) {
                    if (canUse) {
                        if(mouseOver()) {
                            if (ds_priority_find_min(CONTROLS.clickableUnderPointer) == id) {
                                y = (owner.hand.handY - 30);
                                //depth -= 10; // make it appear above all other cards
                            }
                        }
                        
                        if (clicked == true) {
                            clicked = false;
                            
                            if (doubleClickWindow &gt; 0) {
                                show_debug_message("Double-click registered : "+string(id));
                                castingChecking = true;
                                doubleClickWindow = 0;
                            } else {
                                doubleClickWindow = CONTROLS.doubleClickWindowMax;
                            }
                        }
                    }
                }
            }
            
            // visuals
            visible = true;
        }
    }
}


if (position == "board") {
    // normal activation of card (e.g. combat)
    if (clicked == true) {
        tryActivate();
    }
}




// scale and glow
if (displayed) {
    image_xscale = scale;
    image_yscale = scale;
}

// allow this card to be selected as an effect target
allowSelectAsEffectTarget()

// move the card into the targetX and targetY
slideIntoPosition();

organizeEnchantments(id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// no glow
glowing = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destruction Event (Sent to Graveyard)

// tell enchantments on this card that they should be destroyed
for (var i = ds_list_size(enchantments) - 1; i &gt;= 0; i--) {
    var enchantment = ds_list_find_value(enchantments, i);
    
    //removeEnchantment(enchantment);
    with(enchantment) {
        show_debug_message(string(id) + " told to be destroyed.");
        event_user(CONST_DESTROY_EVENT);
    }
    
    show_debug_message("current i: " + string(i));
}

// Go to graveyard by default. Specific cards can override this
sendToGraveyard(owner.graveyard, id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw self and card elements
event_inherited();
//draw_set_alpha(1);
//draw_set_color(c_black);

if (surfaceDrawn == false) {
    getCardSurface(id);
}

if (displayed) {
    if (!faceUp) {
        draw_sprite_ext(sprite_index, 0, x, y, scale, scale, 0, c_white, 1); // draw the back of the card
    } else {
        if (cardSurfaceSprite != noone) {
            draw_sprite_ext(cardSurfaceSprite, 0, x, y, scale, scale, image_angle, c_white, 1);
        }
        
        // darken card if it can't be played
        if (canUse == false) 
        or (activated == true) {
            fx_darken_card();
        }
    }
    
    glow_sprite = cardSurfaceSprite;
    check_glow();   // draw the hover glow over the sprite
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
