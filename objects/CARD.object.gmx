<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>TARGETABLE</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// CLASS VARS
event_inherited();

name            = "";
class           = "";
description     = "This is the default card and if you're reading this, something went wrong";
castingCost     = 1;
abilities       = ds_list_create();
classes         = ds_list_create();
sprite_index    = spr_card;
image_index     = round(random(image_number - 1));
image_speed     = 0;
scale           = global.card_hand_scale;
fullyDrawn      = false;        // a check for animation
carddraw_xSpeed = 10;//room_width / room_speed;
cardSlideSpeedMax = 10;
cardSnapDistance= 4;
targetX         = room_width * 0.5;
targetY         = y;
casting         = false;
castingChecking = false;
activate        = false;
displayed       = false;        // display or don't display the card
position        = "none";       // in "hand", in "deck", on "board", in "graveyard", or "none"
faceUp          = false;        // 0 or 1, false or true, it corresponds to the image_index.
canUse          = false;
clicked         = false;
canPlay         = true;
canPlayFromGraveyard = true;
setup_glowing();



/// CARD ELEMENTS

// casting cost
base_castCircleX = 278;
base_castCircleY = 4;
castCircleX = base_castCircleX;
castCircleY = base_castCircleY;
base_castingCostX = 295;
base_castingCostY = 5;
castingCostX = base_castingCostX;
castingCostY = base_castingCostY;

base_nameX = 35;
base_nameY = 3;
nameX = base_nameX;
nameY = base_nameY;

base_classX = 35;
base_classY = 260;
classX = base_classX;
classY = base_classY;

base_descriptionX = 35;
base_descriptionY = 303;
descriptionX = base_descriptionX;
descriptionY = base_descriptionY;
base_descriptionWidth = 280;
descriptionWidth = base_descriptionWidth;
base_separation = 30;
separation = base_separation;

base_artX = 22;
base_artY = 43;
artX = base_artX;
artY = base_artY;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// state and element positions
event_inherited();

if (displayed == false) {
    visible = false;
}

image_index = faceUp;
canUse = false;

switch (position) {
    case "deck":
        displayed = false;
        break;
    
    case "drawing":
        displayed = true;
        fullyDrawn = false;
        faceUp = false;
        visible = true;
        scale = global.card_hand_scale;
        depth = global.drawing_depth;
        y = owner.hand.handY;
        targetY = owner.hand.handY;
        
        // finish
        if (x == targetX) {
            position    = "hand";
            fullyDrawn  = true;
            faceUp      = true;
        }
        break;
    
    case "hand":
        if (global.GAME_PHASE == "main1")
        or (global.GAME_PHASE == "main2") then canUse = true;
        scale = global.card_hand_scale;
        y = owner.hand.handY;
        break;
        
    case "board":
        canUse = true;
        displayed = true;
        scale = global.card_board_scale;
        break;
        
    case "graveyard":
        if (canPlayFromGraveyard)
            then canUse = true;
            else canUse = false;
        y = owner.hand.handY;
        break;
}



if ((position == "hand") or (position == "graveyard")) {
    if (displayed) {
        // interactivity
        if (mouseOverCard() == id) {
            if (canUse) {
                y = (owner.hand.handY - 30);
                depth -= 10; // make it appear above all other cards
                
                if (clicked == true) {
                    clicked = false;
                    
                    if (doubleClickWindow &gt; 0) {
                        show_debug_message("Double-click registered : "+string(id));
                        castingChecking = true;
                        doubleClickWindow = 0;
                    } else {
                        doubleClickWindow = CONTROLS.doubleClickWindowMax;
                    }
                }
            }
        }
        
        // visuals
        visible = true;
        if (owner == global.enemy) {    // flip opponent's card on face
            image_index = 0;
            faceUp = false;
        }
    } else {
        visible = false;
    }
}


if (position == "board") {
    // allow this card to be selected as a combat target
    if (global.choosingTarget == true) {
        if (mouseOverCard() == id) {
            if (clicked) {
                clicked = false;
                global.currentCard.target = id;
            }
        }
    } else {
        // normal activation of card (e.g. combat)
        if (mouseOverCard() == id) {
            if (clicked == true) {
                if (doubleClickWindow &gt; 0) {
                    activate = true;
                    clicked = false;
                } else {
                    doubleClickWindow = CONTROLS.doubleClickWindowMax;
                }
            }
        }
    }
}


// check if can't be played so we can darken the card
canPlay = check_canPlayCard();


// move the card into the targetX and targetY
cardSlideIntoPosition();

if (displayed) {
    // visuals
    image_xscale = scale;
    image_yscale = scale;
    positionCardElements();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// no glow
glowing = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw self and card elements


draw_set_alpha(1);
draw_set_color(c_black);

if (displayed) {

    draw_self();
    
    if (faceUp) {
        // name text
        switch (position) {
            case "hand":
            case "graveyard":
                draw_set_font(global.font_CardBold_Hand);
            break;
            
            case "board":
                draw_set_font(global.font_CardBold_Board);
            break;
        }
        draw_text(nameX, nameY, name);
        
        
        // casting cost
        draw_set_halign(fa_center);
        draw_sprite_ext(spr_cost_circle, 0, castCircleX, castCircleY, scale, scale, 0, c_white, 1);
        draw_sprite_ext(spr_card_castingCost_numbers, castingCost, castingCostX, castingCostY, scale, scale, 0, c_white, 1);
        draw_set_halign(fa_left);
        
        
        // art
        draw_sprite_ext(image, image_index, artX, artY, scale, scale, 0, c_white, 1);
        
        
        // class text
        switch (position) {
            case "hand":
            case "graveyard":
                draw_set_font(global.font_CardText_Hand);
            break;
            
            case "board":
                draw_set_font(global.font_CardText_Board);
            break;
        }
        draw_text(classX, classY, class);
        
        
        // abilities text
        var str = "";
        for(var i=0; i&lt;ds_list_size(abilities); i++) {
            var ability = ds_list_find_value(abilities, i);
            if !(is_undefined(ability)) {
                str += string(ability) + ", ";
            } else break;
        }
        // replace the last ", " with "."
        if (str != "") {
            str = string_copy(str, 1, string_length(str)-2);
            str += ".#"; // "." and newline
        }
        
        
        // description text
        switch (position) {
            case "hand":
            case "graveyard":
                draw_set_font(global.font_CardText_Hand);
            break;
            
            case "board":
                draw_set_font(global.font_CardText_Board);
            break;
        }
        
        draw_text_ext(descriptionX, descriptionY, str + string(description), separation, descriptionWidth);
        
        
        
        // darken card if it can't be played
        if (canPlay == false) {
            fx_darken_card();
        }
    }
    
    check_glow();   // draw the hover glow behind the sprite
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
